    ● ANGULAR @[https://angular.io/docs] [Official Doc]
[[{$div]]
[[{stack.angular,02_doc_has.resource]]
● Ext.Links
- Angular API:
@[https://angular.io/api?type=package]
- Github Repo:
@[https://github.com/angular/angular]
────────────────────────────────────────────────────────────────────────────────
● What's new
•  Angular 11
  @[https://www.infoq.com/news/2020/11/angular-11/]
  @[https://blog.angular.io/version-11-of-angular-now-available-74721b7952f7]
  - Hot Module Replacement implementation:
  $ $ ng serve --hmr   ← It can be initialized with --hmr flag.
                         NG app will not need full page refresh on code changes:
                         Instead, latest changes to code/style/templates will be
                         updated directly while preserving the current state of
                         the application.

  - Build process speed boost by upgrading to TypeScript 4.0
    and through improving the ngcc update process.

  - developers can now opt-in to the experimental Webpack 5 support
    (faster builds with persistent disk caching and smaller bundle sizes
     using improved tree-shaking).  To enable it:
     "resolutions": { "webpack": "5.4.0" }  ← Add to package.json

  - NG language service (popular add-on offers autocomplete, type checking, etc...)
    is being transitioned to the new Ivy engine, offering improved support for
    generic types.

  - For simple upgrade of projects:
  $ $ ng update @angular/cli @angular/core
    WARN : for more complex updates, use the interactive update guide
           provided by the Angular team.

•  Angular 9
@[https://www.infoq.com/news/2020/02/angular-9-ivy-rendering-engine/]
  • Ivy Compiler:
    Smaller bundle sizes, improved build times, and better debugging
    thanks to the release of the much anticipated Ivy rendering engine
    that has been in development by Google since 2018.
      Ivy uses tree shaking, allowing it to include only the parts of
    Angular needed for the current application.

•  Angular 5
 Service worker implementation shipping by default.
[[}]]

[[{stack.angular.101]]
● Architecture #[angular_summary]
@[https://angular.io/guide/architecture]
  VIEW : "screen element" on browser, mobile, ...

  COMPOMENT : $  $ ng generate component "compName"
  • Typescript Class with ng-decorator.

  • Defines N views, arranged hierarchically.
    The (optional)  Router service  defines navigation paths
    among them.

  • At least one  root component  is needed by App, connecting a
    component hierarchy with the page document object model (DOM).

  •  Service  (providers) are injected (@Injectable() decorator) to provide
    needed non-visual functionality.

  • When a component is instantiated, it's associated directly with
    the (root) host view.

                           DATA
   TEMPLATE  == HTML +    BINDING     + DIRECTIVES
                          MARKUP      @[https://angular.io/guide/built-in-directives]
                          └─┬──┘        └───┬────┘
               ┌────────────┘               └ There can be:
   FRONTEND    │                     ANGULAR  ├─ Component directives (the most common)
    DOM        │                    COMPONENT │
    └┬┘ ┌──────┴─────────────────┐  └───┬───┘ ├─ Attribute Directives:
     │                                  │     │  - [ngClass]="JS expression"
     ←················  {{value}} ···· ←┤     │  - [ngStyle]="JS expression"
     │                                  │     │  - NgModel two way data binding:
     │                                  │     │
     ←·······  [property]="value" ···· ←┤     │    PRE-SETUP: add FormsModule to @"X".module.ts
     │                                  │     │    imports:[...,FormsModule]
     │                                  │     │
     ├─··→·  (click)="handler" ·········→     │    <input [(ngModel)]="model.field01" id="field01">
     │                                  │     │
     │                                  │     │
     ←····  [(ng-model)]=comp.varName ··→     └─ Structural directives: add/remove elements
     │                                  │
           -----------------------               NgIf, NgFor, NgSwitch:
      Two way binding (forms mainly). Ex:      <app-item *ngIf="isActive" [item]="item">...
      <input [(ngModel)]="hero.name">
                                               <div *ngFor="let I of items">{{I.name}}</div>
 ☞  All data bindings are processed once
    for each JS event cycle from app           <div [ngSwitch]="e.index">
    root component through tree children.        <comp1 *ngSwitchCase="'1'" [item]="ddbb[1]"></comp1>
                                                 ...
                                                 <comp1 *ngSwitchDefault    [item]="ddbb[0]"></comp1>
                                               </div>

  e.g.: <input type="text" [(ngModel)]="inputIdentity" (change)="userInputFromUICallback()">

    TEMPLATE    : template → evaluate   → resolve  → modify
    EVALUATION    input      directives   binding    HTML DOM
                                          syntax


    TEMPLATE PIPES  (data transformation)
    • Ex: date data → pipe → locale-date
    • Predefined Pipes (@[https://angular.io/api?type=pipe]):
      Async , Currency , Date , Decimal, I18n(Plural|Select), JSON,
      KeyValue, (Lower|Upper)Case , Percent , Slice , TitleCase

User click → (intercepted by) → Router  → (reacts by) → showing/hiding view hierarchies.
                                                        ( lazy load    └───────┬──────┘
                                                         of related modules)   │
       ┌····································  hierarchical structure is key ···┘
       │                                      to how Angular detects/reacts
       │                                      to changes in the DOM|app data.
   ┌───┴─────┐
┌→ view root   ←→ NgModule1.rootComponent ┐ ← boostrapping module  (ex. app.module.ts)
·   └- view1   ←→ NgModule1.component1    ├ A view hierarchy can include
·   └- view2   ←→ NgModule2.rootComponent │ views from components in the
·     └- view3 ←→ NgModule2.component3    ┘ same or different NgModule
·                 └───┬───┘ └───┬───┘
·                     |     @[https://angular.io/guide/architecture-components]
·                     |     - (typescript) app logic controling a view
·                     |       through an properties+methods API.
·                     |     -
·  @[https://angular.io/guide/architecture-modules]
·  -  container|scope for a set of (component list, Service list, ...)
·  -  compilation context  for components:
·  -  orthogonal app-domain|workflow|capabilities set.
·  -  can depend on other (imported) NgModules
·
└→ Ex Module: app.module.ts:
   import {  NgModule  }      from '@angular/core';             ← JS input
   import {  BrowserModule  } from '@angular/platform-browser'; ← JS input
   @NgModule ({                         ← Decorator function.
     imports :     [   BrowserModule  ],
     providers :   [ Logger ],         ← Creators of services that this NgModule
                                         contributes to.  (providers at component
                                         level can also be specified , which is
                                         often preferred).
                                         A service declared here also ensures that it
                                         will be available as a singleton instance to
                                         any other component/service.

     declarations: [ AppComponent ],   ← components|directives|pipes declared

     exports:      [ AppComponent ],   ← (opt) Subset of declarations accesible
                                         by templates in other NgModules

     bootstrap:    [ AppComponent ]    ← (Only root module): main app view
   })
   export class AppModule { }          ← JS export (vs NgModule export)



 → Ex Component: src/app/hero-list.component.ts
   @Component ({
     selector   : 'app-hero-list',               ← associated html tag name
┌→   templateUrl: './hero-list.component.html',  ← seteable property programatically
·┌   providers:    [HeroService]                 ← required Service prov. array
·· })                                              Size must match constructor arg. size
··
·· export class HeroListComponent implements  OnInit  {
··   heroes      : Hero[]; ← data app property. Note: Many components wrap all
··   selectedHero: Hero;   ← data app property        data in a model dict to make code
··                                                    more readable.
·└   constructor   (private service:HeroService)  ← service will be injected
·    { ...}                                         Must match @Component.providers
·
·     @Input() hero : Hero;   // ← @Input() marks field as input, bounding it
·     @Input() power: string; //   to template DOM prop. Used to comunicate data
·                             //   among parent←→children components.
·                                @[https://angular.io/guide/inputs-outputs]
·     ...
·     ngOnChanges(change_map: SimpleChanges) { // @[https://angular.io/api/core/OnChanges]
·                 └───────────┬───────────┘
·     /*  lifecycle hook called when data-bound properties change.
·      *  Implemented by NgModel, FormControl*, Max/MinLenghtValidator, ...
·      *  maps each changed property to a SimpleChange
·      *  instance with (current,previous) values. */
·       for (let key in change_map) {
·         let chng = change_map[key];
·         let cur  = JSON.stringify(chng. currentValue);
·         let prev = JSON.stringify(chng.previousValue);
·         .log('PropName: ${key}: Val: ${cur}, previous ${prev}');
·       }
·     }
·
·
·    ngOnInit()  {                               ←·lifeCycle hook
·      this.  heroes  = this.service.getHeroes();  See also detailed examples at:
·    }                                       @[https://angular.io/guide/lifecycle-hooks]
·    selectHero(hero: Hero) { this.selectedHero = hero; }              │
·  } └─────────┬──────────┘                                            │
·              └─────────────────────────────────────────┐             │
·                                                        │             │
└→ Ex template: src/app/hero─list.component.html         │             │
   <h2>Hero List</h2>                                    │             │
   Pick a hero from list:                                │             │
   <ul>                                          ┌───────┴──────┐      │
     <li  *ngFor ="let hero of   heroes "  (click) ="selectHero(hero)">│
         {{hero.name | UpperCase}}                                     │
     </li>                                                             │
   </ul>                                                               │
                                                                       │
    <app-hero-detail            ← another component                    │
      *ngIf ="selectedHero"                                            │
      [hero] ="selectedHero">                                          │
    </app-hero-detail>                                                 │
    <on-changes [hero]="hero" [power]="power"></on-changes>            │
                                                                       │
           ┌───────────────────────────────────────────────────────────┘
   ┌───────┴───────────┐
   Main Life-cycle Hooks  for Component(or Directive in general):
   HOOK                                 PURPOSE AND TIMING
   ────                                 ──────────────────
   ngOnChanges(changes: SimpleChanges)  (re)sets data-bound input properties.
   ngOnInit()                           Initialize component after first display
                                        with data-bound properties and sets the
                                        directive/component's input properties.
   ngDoCheck()                          Detect and act upon changes that Angular
                                        can't or won't detect on its own.
   ngAfterContentInit()                 Respond after Angular projects external content
                                        into the component's view
   ngAfterContentChecked()              ...
   ngAfterViewInit()                    ...
   ngAfterViewChecked()                 ...
   ngOnDestroy()                        tap into Cleanup just before Angular destroy
                                        Use it to Unsubscribe Observables and detach
   Other hooks:                         event handlers to avoid memory leaks.
   - Angular sub-systems
   - 3rd party libraries may add new hooks.


└→ Ex Service: src/app/logger.service.ts
 $ $ ng generate service ...
   Service:  "Do one thing and do it right" (root/module/component)singleton .
   - Injected in components through constructors.
   @Injectable()
   export class Logger {
     log  (msg: any) { console.log  (msg); }
     error(msg: any) { console.error(msg); }
     warn (msg: any) { console.warn (msg); }
   }

   Note on Services injection procedure:
   Angular will create 1+providers for each service(or function|value).
   - The provider can be part of the service's own metadata, to make
     it available everywhere, or it can be registered with an specific
     module|component using the respective decorator
     (@Injectable(), @NgModule() or @Component())
     NOTE: If the providers is in @Injectable() decorator, Angular
          will optimize the app by removing it, if it's not used.

   - Service SCOPE:
     ┌──────────┬─────────────────────────────────┬──────────────────────────────
     │ LEVEL    │ Scope                           │ Declaration
     ├──────────┼─────────────────────────────────┼──────────────────────────────
     │ ROOT     │ single instance injected in all │ @Injectable(
     │ (app)    │ app─components (Default)        │    {providedIn: 'root'})
     │          │                                 │ (@ service01.service.ts)
     ├──────────┼─────────────────────────────────┼──────────────────────────────
     │ NgModule │ single instance injected in all │ @NgModule( ...
     │          │ module─components               │ { providers:
     │          │                                 │     [ service01, service02 ]
     │          │                                 │ })
     ├──────────┼─────────────────────────────────┼──────────────────────────────
     │ Component│ new service instance created for│ @Component({
     │          │ each new component              │   selector   : '...'
     │          │                                 │  ,templateUrl: '...component.html'
     │          │                                 │  ,providers  : [ service01 ]
     │          │                                 │ })
     └──────────┴─────────────────────────────────┴──────────────────────────────
[[}]]

[[{stack.angular.101,01_PM.WiP]]
● Responsive App
  Observables and event processing
@[https://angular.io/guide/observables]

- similar (but not identical) to the publish/subscribe
  design pattern. In the observer pattern:
  "subject" object  maintains a list o its dependents (observers)
  "subject" automatically notifies dependent observers of state
            changes.

  Component01 →  +Observable: Observable is a function that
                  function    executes only when a consumer subscribes


  Component02 → Component02 : create Component02.Observer01
  Component02 →  Observable : subscribe (Component02.Observer01)
                 function

  Observable function
  execution "loop":
     Observable  → Observer01: event (keystroke, HTTP response,
     function                         timer,  ...)

-  Setup and teardown logic is handled by the observable function .
   application code in Component02 only needs to worry about
   subscribing to consume values, and when done, unsubscribing
   It doesn't change whether the code was sync or async.

 - Unicast example:
   const   observable01  =
       new Observable(
     /*
      * This code creates a new independent execution for each
      * subscribed observer creating a relation
      *      Execution 1 ←→ 1 Subscriber
      * (vs) Execution 1 ←→ N Subscriber  ("Multicast")
      */
         (observer) {  ← function to execute at ".subscribe(...)
         const {nextCallback, errorCallback} = observer;
         let watchId = navigator.geolocation
              .watchPosition(nextCallback, errorCallback);
         return {
           unsubscribe() {       // ← ☞ Freing resources is
             navigator.geolocation.   responsability of Observable
               clearWatch(watchId);
           }
         };
       } );

    const   subscription01  = O observable01 .subscribe(
    {
      next(position) { console.log(position);       },
      error(msg)     { console.log('Error: ', msg); },
    });
    ...
    setTimeout(() => { observable01.unsubscribe(); }, 10000);

 - Multicast example:
   ☞TIP: multicasting tools simplify next code by allowing
         to convert any existing observable to "multicast".

    // Emit one value/second until end-of-array.
┌·→ function executor(observer, arr, idx) { ←┐
|     return setTimeout(() => {              |
|       observer.next(arr[idx]);             |
|       if (idx === arr.length - 1) {        |
|         observer.complete();               |
|       } else {                             |
|         executor(observer, arr, ++idx); ···┘
|       }
|     }, 1000);
|   }
|
|   /*
|    * multicastSequenceSubscriber wraps the executor
|    * keeping state of subcribers.
|    */
|   function multicastSequenceSubscriber() {
|     const seq = [1, 2, 3];
|     const   observers  = [];  // ← Keep track o subscribers
|     // Still a single timeoutId because there will only ever be one
|     // set of values being generated, multicasted to each subscriber
|     let timeoutId;
|
|     // Return the subscriber function (runs when subscribe()
|     // function is invoked)
|     return (observer) => {
|       observers .push(observer);
|       if (  observers .length === 1) {
|       //  ^^^^^^^^^^^^^^^^^^^^^^
|       // start executor at 1st subcription only
└··       timeoutId = executor({
            next(val) {
                observers .forEach(obs => obs.next(val));
            },
            complete() {
                observers .forEach(obs => obs.complete());
            }
          }, seq, 0);
        }

        return {
          unsubscribe() {
            observers.splice(observers.indexOf(observer), 1);
            if (observers.length === 0) {
              clearTimeout(timeoutId);
            }
          }
        };
      };
    }

    const mcastObservble01 = new Observable(multicastSequenceSubscriber());

    setTimeout(() => {
      multicastSequence .subscribe ({
        next (num) { console.log('1st subscribe: ' + num);  },
        complete() { console.log('1st sequence finished.'); }
      });
    },    0 /*← Subscribe "now"*/ );

    setTimeout(() => {
      multicastSequence .subscribe ({
        next (num) { console.log('2nd subscribe: ' + num); },
        complete() { console.log('2nd sequence finished.'); }
      });
    }, 1500 /*← Subscribe after 1st event */ );

    Console will show:
    (second 1) → 1st subscribe: 1
    (second 2) → 1st subscribe: 2
      "        → 2nd subscribe: 2
    (second 3) → 1st subscribe: 3
      "        → 1st sequence finished
      "        → 2nd subscribe: 3
      "        → 2nd sequence finished

- EX USING REACTIVE RX.JS:

  ┌─ Observable Service (EVENT EMITTER) ────  ┌─ Observer Component (EVENT CONSUMER) ─────
  │ import {Subject} from 'rxjs';             │ import { Component } from '@angular/core';
  │ // npm i -s rxjs@v6.5.3                   │ import { ServiceX} from ...
  │                                           │
  │ @Injectable()                             │ @Component({
  │ export class ServiceX {                   │    selector: ...
  │   ...                                     │    templateUrl: ...
  │   public infoObservable =                 │    providers: ...
  │     new Subject<string[]>();              │    styleUrls: ...
  │                                           │ })
  │   private async refreshInfo() {           │ export class Comp01 implements OnInit {
  │      ...                                  │
  │      const info = await getRemoteInfo()   │   constructor(
  │      this.infoObservable .next(info);     │     private myService : ServiceX ) {
  │   }                                       │     ...
  │ }                                         │   }
  └─────────────────────────────────────────  │
                                              │   ngOnInit() {
                                              │     this.myService.
                                              │       .infoObservable.subscribe(
                                              │        ( info ) => { /* "consume info */ }
                                              │     )
                                              │   }
                                              └───────────────────────────────────────────
[[}]]

[[{stack.angular]]
● PrimeNG Library
@[https://www.primefaces.org/primeng/#/]
• See also other "top" Frameworks:
@[https://www.ngdevelop.tech/best-angular-ui-component-libraries/]

•  PRE-SETUP
 $ $ npm install primeng --save
 $ $ npm install primeicons --save
 $ $ npm install @angular/animations --save   (opt)
         ^
    Or manually add dependencies to
    package.json add like :
    ...
    "dependencies": {
        ...
  +     "primeng": "^10.0.0",
  +     "primeicons": "^4.0.0"
        ...
    }
• 95% of code is native with no 3rd party dependencies
• UI component library configured as ng-modules. e.g:
  import {AccordionModule} from 'primeng/accordion'; //accordion and accordion tab
  import {MenuItem}        from 'primeng/api';       //api
• Lot of free themes out-of-the-box.

• Ex. config. for required styles:
    "styles": [
      "node_modules/primeng/resources/themes/saga-blue/theme.css",
      "node_modules/primeng/resources/primeng.min.css",
      "node_modules/primeicons/primeicons.css",
      ...
    ],
    ...
• See also: PrimeNG Video Tutorial:
@[https://www.youtube.com/watch?v=4Wk4RgYN9ZQ&list=PLEXcOZ7ShIgAnxrnPgiOpIz1uPKZNQ9ZJ]
[[}]]

[[{stack.angular.101,mobile.pwa,code.async,data_management.cache,02_doc_has.comparative,performance.cache,devops,01_PM.TODO]]
● Service Workers  @ma #[angular_service_worker]
@[https://angular.io/guide/service-worker-intro]
• See general introduction to Service workers at #[service_workers_summary]
• The Angular service worker's (v5.0+) design goal:
  • Caching app as one unit. The running app will use the               [devops]
    same version of all files (vs randomnly receiving cached
    files from a newer incompatible version).
  • Refreshing will show latest fully cached version.                   [devops]
    with updates executing in background.
  • NG service will load the PWA manifest file from the server
    describing the resource to cache.  When an update to the
    PWA is deployed, manifest data changes triggering the
    background update.
  • TheB manifest is generated from "ngsw-config.json" .                [devops]

• NG Service how-to:
  • Include  NgModule ????                                                [TODO]
  • Registering NG Service Worker with the browser:
    •  WARN:  PWApp must be accessed over HTTPS, not HTTP.
              Otherwise, registration will fail to avoid
              tampering. (security meassure since Service Workers
              are "quite powerful").
              Exception: localhost is allowed for developers.

  • See Service Worker config at:                                         [TODO]
  @[https://angular.io/guide/service-worker-config]
  • See Service Worker production ready at:                       [TODO][devops]
  @[https://angular.io/guide/service-worker-devops]
[[}]]

[[{]]stack.angular.forms,mobile.pwa,qa.error_control,code.low_code,01_PM.BACKLOG" >
● Interactive Forms
@[https://angular.io/guide/forms]
Support complex data entry scenarios with HTML-based validation and dirty checking.

- template-driven interactive form how-to

  - Requested features:
  - from with control elements bound to data properties
  - input data integrity validation with two-way data binding


- design approaches:
  -  Alt 1: write templates using:
           - NG template syntax
           - form-specific directives
           - "best-pattern".
    - suitable for small or simple forms

  -  All 2: Use reactive(==model-driven) approach
    - lay out the controls creatively, binding to the data in your object model.
    - Set input validation rules and output display validation errors.
    - conditionally enable controls.
    - trigger built-in visual feedback,
    - ...
_________________________________________________________
  Alt 1: template-driven form
  - Next directives defined in  FormsModule  are used:.
    - NgModel : reconcilites "form element"  ←→ data model value changes
                - used also to respond to user input (input validation, error handling).

    - NgForm : - creates top-level  FormGroup  instance bined to <form> DOM.
               - track aggregated form value and validation status.
               - active by default on all <form> tags at "FormsModule" import
                 (it has a selector matching the <form> element).

    - NgModelGroup : create+bind  FormGroup  instance  ←→ DOM element.

  - STEPS:
    - Define a sample data model.
    - Include FormsModule,... "stuff".

    - Bind form-controls ←→ data properties with  ngModel
      - Examine how ngModel reports control states using CSS classes.
      - Name controls to make them accessible to ngModel.

    - Track input validity/control status with  ngModel
      - Add custom CSS to provide visual feedback on the status.
      - Show and hide validation-error messages.

    - Respond to a native HTML button-click event by adding to the model data.

    - Handle form submission using form  ngSubmit  output property.
      - Disable the Submit button until the form is valid.
      - After submit, swap out the finished form for different content on the page.


Ex: two required fields (css:left border when OK, red otherwise)
     with initial default values.

    - src/app/hero.ts: (Model)

      export class Hero {
        constructor(
          public id: number,
          public name: string,
          public power: string,
          public alterEgo?: string
        ) {  }
      }

    - src/app/hero-form/hero-form.component.ts: (v1) (layout, details)

      import { Component } from '@angular/core';
      import { Hero } from '../hero';

      @Component({
        selector: 'app-hero-form', ·············· ← drop form in parent template using  <app-hero-form>
        templateUrl: './hero-form.component.html',
        styleUrls: ['./hero-form.component.css']
      })
      export class HeroFormComponent {

        powers = ['Really Smart', 'Super Flexible',
                  'Super Hot', 'Weather Changer'];

        model = new Hero(18, 'Dr IQ', this.powers[0], 'Chuck Overstreet');

        submitted = false;

        onSubmit() { this.submitted = true; }

        // TODO: Remove this when we're done
        get diagnostic() { return JSON.stringify(this.model); }
      }


    - src/app/app.module.ts:
      import { NgModule } from '@angular/core';
      import { BrowserModule } from '@angular/platform-browser';
      import { FormsModule } from '@angular/forms';              ← enable Forms feature

      import { AppComponent } from './app.component';
      import { HeroFormComponent } from './hero-form/hero-form.component';

      @NgModule({
        imports     : [ BrowserModule, FormsModule ],
        declarations: [ AppComponent, HeroFormComponent ],
        providers   : [],
        bootstrap   : [ AppComponent ]
      })
      export class AppModule { }

    - src/app/app.component.html:
      <app-hero-form></app-hero-form>  ← display at root component's template.

    - src/styles.css:
      (Twitter Bootstrap style classes: container/form-group/form-control/btn)
      @import url('https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css');

    - src/app/hero-form/hero-form.component.html
      <style> .no-style .ng-valid   { border-left: 1px  solid #CCC } ; ...  </style>

      <div class="container">
        <div [hidden]="submitted">  ←  main form visible by default since submitted init to  false

          <form (ngSubmit)="onSubmit()" #heroForm="ngForm">
                                        └───┬────────────┘
                                            └──── Access overall form status
                                                  #heroForm : tpl ref.var is now a ref. to
                                                              NgForm directive inst.governing form
                                                              as a whole.
            <div class="form-group">
              <label for="name">Name</label>
              <input type="text" class="form-control" id="name"
                                                      └───┬──┘
                                                          └──────────── (standard HTML). used by <label> to match
                     required
                     [(ngModel)]="model.name"
                     └──────────┬───────────┘
                                └──────────── two-way data binding. model.name server to display and debug that
                                              model is really being updated when user changes input.
                                              NG sets special CSS classes on (NgModel) control elements to
                                              reflect the state.
                                              ┌─────────────────────────────────┬────────────┬─────────────┐
                                              │State                            │ Class      │ Class       │
                                              │                                 │ if true    │ if false    │
                                              ├─────────────────────────────────┼────────────┼─────────────┤
                                              │The control has been visited.    │ ng─touched │ ng─untouched│
                                              ├─────────────────────────────────┼────────────┼─────────────┤
                                              │The control's value has changed  │ ng─dirty   │ ng─pristine │
                                              ├─────────────────────────────────┼────────────┼─────────────┤
                                              │The control's value is valid.    │ ng─valid   │ ng─invalid  │
                                              └─────────────────────────────────┴────────────┴─────────────┘

                     name="name"
                     └───┬─────┘
                         └──────────── [(ngModel)] on an element requires also the name attribute for that element, used by NG
                                       to register such element with the NgForm directive attached to parent form element.

                     #name="ngModel">
                     └───┬─────┘
                         └──────────── tpl reference variable that you can use to access the input
                                       box's Angular control from within the template.
                                       It is set to "ngModel" because that is the value of the NgModel.exportAs property.
                                       This property tells Angular how to link a reference variable to a directive.

                          ┌─────────── Show or hide the error message by binding properties
                          │            of the name control to the message <div> element's hidden property
                   ┌──────┴─────────────────────────────┐
              <div [hidden]="name.valid || name.pristine" class="alert alert-danger">Name is required</div>
            </div>                              └──┬───┘
                                                   └──  pristine == user hasn't changed the value since it was displayed.

            <div class="form-group">
              <label for="alterEgo">Alter Ego</label>
              <input type="text" class="form-control" id="alterEgo"
                     [(ngModel)]="model.alterEgo" name="alterEgo">
            </div>

            <div class="form-group">
              <label for="power">Hero Power</label>
              <select class="form-control" id="power"
                      required
                      [(ngModel)]="model.power" name="power"
                      #power="ngModel">
                <option *ngFor="let pow of powers" [value]="pow">{{pow}}</option>
              </select>
              <div [hidden]="power.valid || power.pristine" class="alert alert-danger">
                Power is required
              </div>
            </div>

            <button type="submit" class="btn btn-success" [disabled]="!heroForm.form.valid">Submit</button>
                                                          └─ automatically hiddes if ─────┘
                                                             form is invalid

            <button type="button" class="btn btn-default" (click)="newHero(); heroForm.reset()">New Hero</button>
            <i>with</i> reset

            &nbsp;&nbsp;
            <button type="button" class="btn btn-default" (click)="newHero()">New Hero</button>
            <i>without</i> reset

           <!-- NOT SHOWN IN DOCS -->
            <div>
              <hr>
              Name via form.controls = {{showFormControls(heroForm)}}
            </div>
           <!-- - -->
          </form>
        </div>

        <div [hidden]="!submitted">
            <div class="col-xs-3">Name      </div> <div class="col-xs-9">{{ model.name }}</div>
            <div class="col-xs-3">Alter Ego </div> <div class="col-xs-9">{{ model.alterEgo }}</div>
            <div class="col-xs-3">Power     </div> <div class="col-xs-9">{{ model.power }}</div>
          <button class="btn btn-primary" (click)="submitted=false">Edit</button>
        </div>
      </div>

  - customizing CSS :
    └ src/assets/forms.css:
    · .ng-valid[required], .ng-valid.required  {
    ·   border-left: 5px solid #42A948; /* green */
    · }
    ·
    · .ng-invalid:not(form)  {
    ·   border-left: 5px solid #a94442; /* red */
    · }
    ·
    ·
    └ src/index.html (styles)
        <head>
        ...
        <link rel='stylesheet' type='text/css' href='...' />

    but it does trigger a form-submit event because of its type (type="submit").
[[}]]
[[$div}]]

[[{$div]]
● Dev.cycle
[[{stack.angular,01_PM.BACKLOG]]
● JIT Compilation
@[https://angular.io/guide/aot-compiler]
- Angular provides just-in-time (JIT) compilation for the
  development environment, and ahead-of-time (AOT) compilation
  for the production environment.
────────────────────────────────────────────────────────────────────────────────
● Testing platform
@[https://angular.io/guide/testing]
- Run unit tests on your application parts as they interact with the Angular framework.
────────────────────────────────────────────────────────────────────────────────
● Internationalization
@[https://angular.io/guide/i18n]
- Make your app available in multiple languages
  with Angular's internationalization (i18n) tools.
────────────────────────────────────────────────────────────────────────────────
● Security guidelines
@[https://angular.io/guide/security]
- Learn about Angular's built-in protections against common
  web-app vulnerabilities and attacks such as cross-site scripting attacks.
[[}]]

● Setup, build, deploy config
[[{]]stack.angular.101," bgorange>
● ng CLI reference
@[https://angular.io/cli]
- Used to:
  - create projects,
  - generate app. and library code.
  - testing, bundling, deployment.
  - ...

  PRE-SETUP:
  $ $ npm install -g @angular/cli

  BASIC WORKFLOW
  $ $ ng new my-first-project\  ←  create, build, and serve (Wait ~ 1 minute to complete)
  $  --strict                   ←  Opt.  @[https://angular.io/guide/strict-mode]   Forbids "any" type
  $ CREATE ...                  ←  initial app created goes to root project folder
  $ CREATE ...                  ←  Additional apps/library go to ./projects/
  $
  $ $ cd my-first-project          new, basic project
  $ $ ng serve                  ←  Automatic rebuilds on edit!!!
                                   Test server listening at:
                                   http://localhost:4200/

  App Layout :
  - New app contains:
    - source files for root module
      - root component + root template.
    - /src folder:  contains
      - logic
      - data
      - assets.
  within a project folder, use $ $ ng generate ...  to add new
  components,services, pipe code, directives, ...  (or do it manually)

    See more about the Workspace file structure.

  Workspace and project configuration

  NOTE: ☞ WORKSPACE 1  ←→ 1+ Project
                             ^^^^^^^
                             application or
                             shareable lib

  ${WORKSPACE}
  └ ./angular.json ← workspace per-project defaults for "ng" command
                     like custorm target defaults, ...
                     Edit it manually or through $ $ng config ...

    See more about Workspace Configuration.
    See the complete schema for angular.json.

  ng syntax:
$ $ ng commandNameOrAlias requiredArg --opt1 --boolOpt2 --noBoolOpt3
                                      └─────────────┬──────────────┘
                     NOTE: opt.names in angular.json are "camelCase".
                           opt.names in ng command   are "camelCase" or
                                                         "dash-case".

$ $ ng generate  "artifact or library to be generated"
$ $ ng add       "artifact or library to be added"
       └──┬───┘  └──────────────────────────────────┘
          │       each artifact/library defines its
          │       own options in a schematic.
     ┌────┴─────────────────────────────────────────────────────────┐
     - add
     - analytics  https://angular.io/cli/usage-analytics-gathering.
     - build      output to dist/
     - config
     - deploy
     - doc        Opens Official Angular documentation in browser,
                  and searches for a given keyword.
     - e2e        Builds and serves an Angular app, then runs
                  end-to-end tests using Protractor
     - generate   Generates/modifies files based on a schematic.
     - help
     - new
     - run        Runs an Architect target with an optional custom builder
                  configuration defined in your project.
     - serve
     - test
     - update     Updates app and dependencies.
                  See @[https://update.angular.io/]
     - version

     - xi18n      Extracts i18n messages from source code.
  Ex:
$ $ ng build              my-app      -c production
                          ^^^^^^
                          generated artifact can also be
                          indicated with --name "my-app"

  Workspace, Project Layout
@[https://angular.io/guide/file-structure]

  ${WORKSPACE}/
  └  .editorconfig
  └  .gitignore
  └  README.md
  └  angular.json
  └  package.json       (npm package dependencies)
  └  package-lock.json  (version information for all npm packages installed)
                        (yarn.lock in case o using yarn)
┌ └  src/               src for root-level  main application project
· └  node_modules/
· └  tsconfig.json      "Solution Style" TypeScript config file. Used by
·                       code editors and TS's language server to inprove dev. experience.
·                       NOT used by compilers . See detailied info about "noImplicitAny",
·                       "suppressImplicitAnyIndexErrors", ... at
·                      @[https://angular.io/guide/typescript-configuration]
· └  tsconfig.base.json base TypeScript config for all (sub)projects in W.S.
· └  tslint.json        Default TSLint config  for all (sub)projects in W.S.
· └  ./projects/        ← Only for (git SCM)  monorepo . Recommended for:
├    └ my-lib01/src       - shareable libraries
·      └ src/lib              library project's logic and data(components,services,
·      ·                      modules, directives and pipes)
·      └ src/test.ts          main unit-test entry point (normally defaults are OK)
·      └ src/public-api.ts    Specifies all files exported from library.
·      └ karma.conf.js
·      └ ng-package.json      Config file used by  ng-packagr  at build time.
·      └ package.json         npm package dependencies required by library.
·      └ tsconfig.lib.json    Lib-custom TypeScript configuration.
·      └ tsconfig.spec.json   TypeScript configuration for the tests.
·      └ tslint.json
·
├    └ py-app02/src       - enterprises using "monorepo" approach.
·      └ ...               In monorepos all developers in all dev.groups
·      └ e2e/              can see all changes from other devs./dev.groups
·        ...               Git becomes the "source-of-true" .
·                          All projects will share similar parent config.
·                          Add new one as:
·                        $ $ ng generate application projectXX (--strict)
· └ e2e/                 End-to-end test files  corresponding to root-level
·   ·                    app, along with test-specific configuration files.
·   └  protractor.conf.js  (test-tool config)
·   └  tsconfig.json       (extends tsconfig.json from workspace)
·   └ src/
·     └  app.e2e-spec.ts   (end-to-end tests for my-app)
·     └  app.po.ts
·
·
└  SOURCE DIRECTORY LAYOUT
   app/            Angular components, templates, styles, logic and data
   └ app.component.ts     : app root component logic ("AppComponent").
                            Its view becomes root of view-hierarchy
                            └──┬───┘
   └ app.component.html   : ←──┘
   └ app.component.css    :
   └ app.component.spec.ts: unit test for root AppComponent.
   └ app.module.ts        : Defines the root module named "AppModule",
                            telling Angular how to assemble the whole app.
                            As you add more components to the app, they must
                            be declared here.

   assets/         images, ... to be copied as-is
   environments/   build config options for a given target
                   By default:
                   - unnamed standard development
                   - production ("prod")
                   - (custom ones can be defined, like acceptance, ...)
   favicon.ico
   index.html      CLI automatically adds all JavaScript and CSS files
                   when building your app, so you typically there is no
                   need to add any script/link tags manually.
   main.ts         App entry point
                   Compiles the application with the JIT compiler and
                   bootstraps the application's root module (AppModule) to
                   run in the browser.
                   - AOT compiler can also be used by appending by using
                   $ $ ng build|serve .... --aot
   polyfills.ts    Polyfill scripts for browser support.
   styles.sass     Lists CSS files supplying styles for a project.
                   (sass extension can vary depending on defaults for project)
                   WARN:!!! sass is in deprecated state. It requires npm packages
                   with lot of dependencies (including gcc/python2/...) when
                   "npm" installing.
                   Don't use it unless you need to maintain a old software.
   test.ts         main entry point for unit tests .
   package.json    (strict mode only)
                   Not used by package managers, it tell tools⅋bundlers whether
                   the code under this directory is free of non-local side-effects.

  APPLICATION-SPECIFIC CONFIG FILES
  .browserslistrc   :  Config sharing of target browsers and Node.js versions
                       among various front-end tools. More info at:
                     @[https://github.com/browserslist/browserslist]
  karma.conf.js     : App-specific Karma configuration.
  tsconfig.app.json : App-specific TypeScript configuration,
                      (TypeScript, ng template compiler options, ...)  [[{01_PM.TODO}]]
                      <!--  ^^^^
                      https://angular.io/guide/typescript-configuration
                      https://angular.io/guide/angular-compiler-options
                      -->
  tsconfig.spec.json: TypeScript config. for the app. tests.
  tslint.json       : App-specific TSLint config.
[[}]]

[[{stack.angular,security.aaa,use_case.identity.openid,standards.identity]]
● NG+Keycloak AAA #[keycloak_angular_openid]
@[https://medium.com/keycloak/secure-angular-app-with-keycloak-63ec934e5093]

 • Core principle behind OpenID-Connect:
   Delegation of  Authentication/Authorization

     ┌─────┐          ┌───────┐          ┌────────┐
     │Alice│          │NG-App │          │Keycloak│
     └──┬──┘          └───┬───┘          └───┬────┘
        │  Can I see      │                  │
        │   this page?    │  Can Alice see   │
        │────────────────>│   that page?     │
        │                 │─────────────────>│
        │ Please, enter (login) credentials? │
        │<───────────────────────────────────│
        │ crendentials (password, token, ...)│
        │───────────────────────────────────>│
        │                 │   OK, Alice      │
        │                 │    can see it    │
        │   page content  │<─────────────────│
        │<────────────────│                  │
     ┌──┴──┐          ┌───┴───┐          ┌───┴────┐
     │Alice│          │NG-App │          │Keycloak│
     └─────┘          └───────┘          └────────┘

•  PRESETUP
  → Keycloak
    → Client Config
      → Add Client :
         Client ID      : angular-test-app
         Client protocol: openid-connect
         Root URL       : https://myapp.mydomain.com ← or dev URL
                                                       (http://localhost:4200)
  → Create new angular app if needed:
    $ $ ng new angular-keycloak
  → Adding official keycloak js adapter
    $ $ npm i keycloak-js --save

• Modify Angular app and next code to main.ts
  let initOptions = { //keycloak init options
    url    : 'https://0.0.0.0:8445/auth',
    realm  : 'keycloak-demo',
    clientId: 'angular-test-app'
  }

  let keycloak = Keycloak(initOptions);

  keycloak
    .init({ onLoad: "login-required" })        //← page load will redirect to
    .success((auth) => {                       //  keycloak Auth. page
      if (!auth) {
        window.location.reload();
        return
      }
      console.log("successful authentication. Bootstrapping now");

      platformBrowserDynamic()
        .bootstrapModule(AppModule)            // ← boostrap module
        .catch(err => console.error(err));

      localStorage.setItem
        ( "ang-token"        ,  keycloak .token);       // Access token
      localStorage.setItem
        ( "ang-refresh-token",  keycloak .refreshToken) // Refresh token

      setTimeout( refreshToken, 60000 /* 1 min*/ )      // May just each hour/day
    })
    .error(() => { console.error("Authenticated Failed"); });

    function refreshToken = () => {
      keycloak .updateToken(70)
      .success( (bRefreshed) => {
          if (bRefreshed) { /* OK */ return ; }
          console.warn('Token not refreshed, valid for '
              + Math.round(
                  keycloak .tokenParsed.exp
                + keycloak .timeSkew
                - new Date().getTime() / 1000) + ' seconds');
        })
     .error(() => { console.error('Failed token refresh'); });
    }


[[}]]


● NativeScript (Native Apps Angular)
[[{stack.angular,mobile.native,stack.vue,mobile.android,mobile.ios,01_PM.TODO]]
● NativeScript
@[https://docs.nativescript.org/]

- Open source framework for building truly native mobile apps with
  Angular, Vue.js, TypeScript, or JavaScript.

- NativeScript features deep integration with modern Angular with
  full-stack features like integration with the Angular CLI, router
  support, code generation, webpack and more.

  External Resources
@[https://github.com/alexziskind1/nativescript-oauth2] [AAA]
@[https://github.com/jbristowe/awesome-nativescript] !!!
@[https://nativescript.org/blog/adding-analytics-to-your-nativescript-app/]
[[}]]

[[{stack.angular,02_doc_has.resource,01_PM.WiP]]
● Recipes
  INIT SERVICE ON PAGE LOAD
  let window: any;
  @Injectable()
  export class MyService01 {
    constructor() {
      window.addEventListener('load' , function (event) { ...  });
    }
  }

  RX Observables:  (TODO:Explain)
  import {Subject} from 'rxjs';
  @Injectable()
  export class MyService01 {
    public accountsObservable = new Subject<string[]  ();
    ...
    this.accountsObservable.next(accs); ← Inject new events
                                          (Will be delivered to observers)

  @Component({ ...  })
  export class MyComponent01 {
    watchAccount() {
      this.myService01.accountsObservable
        .subscribe(function(account_l) { ← Subscribe
        ...                              ← Update component / GUI
      });
    }
  }

[[}]]


[[angular}]]

